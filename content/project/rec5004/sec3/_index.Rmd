---
date: "2018-09-09T00:00:00Z"
# icon: book
# icon_pack: fas
linktitle: Manipulation
summary: It covers topics such as data manipulation, apply functions, etc. Also provides an introduction to the dplyr package and its functions for column manipulation (select, rename, mutate), row manipulation (filter, arrange), and grouping of rows (summarize). The page also includes examples of using these functions with the Star Wars dataset. Additionally, the page discusses the use of the pipe operator (%>%) and join functions for merging data frames.
title: Data Manipulation
weight: 3
output: md_document
type: book
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


> ‚ÄúBetween 30% to 80% of the data analysis task is spent on cleaning and understanding the data.‚Äù (Dasu \& Johnson, 2003)

Para esta se√ß√£o, usaremos a base de dados `starwars` do pacote de manipula√ß√£o de dados `dplyr`:

```{r message=FALSE, warning=FALSE}
library(dplyr)

# Vamos chamar a base de dados starwars de sw
sw = starwars

# vamos retirar as √∫ltimas 3 colunas para facilitar a manipula√ß√£o.
# S√£o colunas da classe list
sw[,c("films", "vehicles", "starships")] = NULL
```


</br>

## Pacote `base`
- Nesta se√ß√£o, vamos manipular bases de dados usando as fun√ß√µes pr√©-carregadas no R (pacote `base`)


### Resumo dos dados

#### Fun√ß√µes b√°sicas
- [Summarizing data (John Hopkins/Coursera)](https://www.coursera.org/learn/data-cleaning/lecture/e5qVi/summarizing-data)
- Verificaremos:
  - as **dimens√µes** da base via `dim()`
  - as 6 **primeiras** linhas da base via `head()`
  - as 6 **√∫ltimas** linhas da base via `tail()`
```{r}
dim(sw) # Verificar tamanho da base (linhas x colunas)
head(sw) # Visualizando as 6 primeiras linhas
tail(sw) # Visualizando as 6 √∫ltimas linhas
```
- Usando `str()`, podemos visualizar a **estrutura** (_structure_) da base:
    - todas a vari√°veis (colunas),
    - a classe de cada uma delas e
    - algumas de suas observa√ß√µes.
```{r}
str(sw)
```


- Para fazer um **resumo** de todas as vari√°veis da base, podemos usar a fun√ß√£o `summary()` que, para vari√°veis num√©ricas, calcula a m√©dia e os quartis, e mostra a quantidade de `NA`.
```{r}
summary(sw)
```

- Note que, para vari√°veis l√≥gicas, de texto (character) ou categ√≥ricas (factor), aparecem poucas informa√ß√µes.
- Logo, pode ser interessante fazer uma **tabela com a contagem** de com as categorias de uma vari√°vel. Isto √© poss√≠vel por meio da fun√ß√£o `table()` e aplicaremos `prop.table(table())` para visualizar em **percentuais**.
```{r}
table(sw$hair_color) # contagem
prop.table(table(sw$hair_color)) # percentual
```
- Tamb√©m podemos fazer uma "contagem cruzada" incluindo mais uma vari√°vel em `table()`:
```{r}
table(sw$hair_color, sw$gender)
```


#### Fam√≠lia de fun√ß√µes _apply_
Veremos uma fam√≠lia de fun√ß√µes _apply_ que permitem executar comandos em loop de maneira compacta:
- `apply`: aplica uma fun√ß√£o sobre as margens (linha ou coluna) de uma matrix/array
- `lapply`: loop sobre uma lista e avalia uma fun√ß√£o em cada elemento
    - fun√ß√£o auxiliar `split` √© √∫til ao ser utilizada em conjunto da `lapply`
- `sapply`: mesmo que o `lapply`, mas simplifica o resultado



##### Fun√ß√£o `apply()`
- [Loop functions - apply (John Hopkins/Coursera)](https://www.coursera.org/learn/r-programming/lecture/IUUhK/loop-functions-apply)
- Usado para avaliar, por meio de uma fun√ß√£o, margens de uma matriz/array
- Frequentemente √© utilizado para aplicar uma fun√ß√£o a linhas ou a colunas de uma matriz
- N√£o √© mais r√°pido do que escrever um loop, mas funciona em uma √∫nica linha
```yaml
apply(X, MARGIN, FUN, ...)

- X: an array, including a matrix.MARGIN: a vector giving the subscripts which the function will be applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2) indicates rows and columns.
- FUN: the function to be applied
```
```{r}
x = matrix(1:20, 5, 4)
x

apply(x, 1, mean) # m√©dias das linhas
apply(x, 2, mean) # m√©dias das colunas
```
- H√° fun√ß√µes pr√©-definidas que aplicam `apply` com soma e com m√©dia:
    - `rowSums = apply(x, 1, sum)`
    - `rowMeans = apply(x, 1, mean)`
    - `colSums = apply(x, 2, sum)`
    - `colMeans = apply(x, 2, mean)`


##### Fun√ß√£o `lapply()`
- [Loop functions - lapply (John Hopkins/Coursera)](https://www.coursera.org/learn/r-programming/lecture/t5iuo/loop-functions-lapply)
- `lapply` usa tr√™s argumentos: uma **lista**, o nome de uma fun√ß√£o e outros argumentos (incluindo os argumentos da fun√ß√£o inserida)
```yaml
lapply(X, FUN, ...)

- X: a vector (atomic or list) or an expression object.
- FUN: the function to be applied to each element of X.
```


<!-- ```{r} -->
<!-- # Criando uma lista com vetor de dimens√µes distintas -->
<!-- x = list(a=1:5, b=45:38, c=c(1, 4, 65, 6, 78)) -->
<!-- x -->

<!-- lapply(x, mean) # retorna m√©dias de cada vetor dentro da lista -->
<!-- lapply(x, summary) # retorna 6 estat√≠sticas de cada vetor dentro da lista -->

<!-- class(lapply(x, mean)) # classe do objeto retornado pelo lapply -->
<!-- ``` -->

- A fun√ß√£o `lapply()` aplica uma fun√ß√£o em cada um de seus elementos.
- Um tipo especial de lista √© o data frame, cujos elementos s√£o suas colunas (vari√°veis).

```{r warning=FALSE}
lapply(sw, mean, na.rm=TRUE) # valores √∫nicos
``` 

- Note que as vari√°veis n√£o num√©rica retornaram `NA` e o 3¬∫ argumento √© um arguemento da pr√≥pria fun√ß√£o `mean()`


- Podemos verificar quais s√£o os valores √∫nicos de cada vari√°vel (um item da lista) usando `unique()`
```{r}
lapply(sw, unique) # valores √∫nicos
``` 

- Um uso interessante √© para a verifica√ß√£o do **n√∫mero de NA's de um data frame**. No entanto, ao transformar uma vari√°vel com `is.na()`, ela se torna uma matriz e, portanto, √© necess√°rio usar fun√ß√£o `apply()`:
```{r}
head( is.na(sw) ) # 6 primeiras linhas aplicando is.na()
class( is.na(sw) ) # tipo de objeto
apply(is.na(sw), 2, sum) # somando cada coluna de TRUE/FALSE
```


##### Fun√ß√£o `sapply()`
Similar ao `lapply`, mas `sapply` tenta simplificar o output:

- Se o resultado for uma lista em seus elementos t√™m o mesmo comprimento, retorna um vetor (ou matriz)
```{r warning=FALSE}
sapply(sw, mean, na.rm=TRUE) # retorna um vetor
```


### Filtro de linhas
- [Subsetting and sorting (John Hopkins/Coursera)](https://www.coursera.org/learn/data-cleaning/lecture/aqd2Y/subsetting-and-sorting)

```{r}
# vetor l√≥gico de cabelo loiro
sw$hair_color == "blond"

# Extraindo linhas com cabelo loiro
sw[sw$hair_color == "blond", ]
```

- Podemos usar express√µes l√≥gicas (vetor com `TRUE` e `FALSE`) para extrair/filtrar uma parte do data frame. Por exemplo, queremos filtrar "Droid" **E** (`&`) que n√£o seja `NA`:
```{r}
sw[sw$hair_color == "blond" & !is.na(sw$hair_color), ]
```

- Para n√£o ter que ficar escrevendo `sw` antes de cada vari√°veis, podemos usar fun√ß√£o `with()`
```{r}
with(sw,
     sw[hair_color == "blond" & !is.na(hair_color),]
     )
```

- Poder√≠amos tamb√©m obter cabelo loiro **OU** (`|`) branco:
```{r}
# Extraindo linhas em que cabelo √© loiro ou branco
sw[sw$hair_color == "blond" | sw$hair_color == "white", ]
```
- Tamb√©m podemos verificar se determinados valores est√£o contidos em um vetor espec√≠fico (equivale a `==` com mais de um valor)
```{r}
sw$hair_color %in% c("blond", "white") # T/F cabelo loiro ou branco
sw = sw[sw$hair_color %in% c("blond", "white"), ]
head(sw)
```


### Ordena√ß√£o de linhas
- [Subsetting and sorting (John Hopkins/Coursera)](https://www.coursera.org/learn/data-cleaning/lecture/aqd2Y/subsetting-and-sorting)

- Podemos usar a fun√ß√£o `sort()` para ordenar um vetor de maneira crescente (padr√£o) ou decrescente:
```{r}
sort(sw$height) # ordenando de maneira crescente
sort(sw$height, decreasing=TRUE) # ordenando de maneira decrescente
```

- Note que n√£o podemos usar a fun√ß√£o `sort()` para ordenar um data frame, pois a fun√ß√£o retorna um vetor com os valores da base de dados.
- Para **ordenar data frames**, precisamos utilizar a fun√ß√£o `order()` que, retorna os √≠ndices dos menores valores aos maiores (ou decrescente com `decreasing = TRUE`):
```{r}
order(sw$height) # √≠ndices na forma crescente de altura
sw = sw[order(sw$height), ] # reordenando data frame
head(sw)
```


### Sele√ß√£o de colunas
- Podemos selecionar colunas usando `[,]` e incluindo um vetor de nomes/√≠ndices das colunas que quer manter (ou retirar usando `!`)
```{r}
# Selecionando 3 primeiras colunas
head( sw[,c("name","height", "mass")] )

# Selecionando 6 primeiras colunas
sw = sw[,1:6]
head(sw)
```


### Renomea√ß√£o de colunas
- Podemos alterar os nomes das vari√°veis usando `names()` ou `colnames()` e atribuindo um vetor de nomes

```{r}
names(sw) # nomes da base de dados

# Retirando os underlines
names(sw)[4] = "haircolor" # alterando um √∫nico
names(sw)[5:6] = c("skincolor", "eyecolor") # alterando 2 nomes
names(sw) # vetor de nomes com altera√ß√£o
```


### Modifica√ß√£o de colunas

- Para modificar vari√°veis, podemos usar `$<novo_nome_var>` e atribuir um vetor de mesmo tamanho (mesma quantidade de linhas):
```{r}
sw$height = sw$height / 100 # de cm para metro
```

- Se incluir um escalar, vai repetir o valor para todas as linhas
```{r}
sw$const = 1
```

- Tamb√©m √© poss√≠vel criar uma nova vari√°vel:
```{r}
sw$BMI = sw$mass / sw$height^2 # √≠ndice de massa corp√≥rea
head(sw)
```


- [Algumas transforma√ß√µes comuns de vari√°veis (John Hopkins/Coursera)](https://www.coursera.org/learn/data-cleaning/lecture/r6VHJ/creating-new-variables)
```{r}
abs(sw$BMI[1:4]) # valor absoluto
sqrt(sw$BMI[1:4]) # raiz quadrada
ceiling(sw$BMI[1:4]) # valor inteiro acima
floor(sw$BMI[1:4]) # valor inteiro abaixo
round(sw$BMI[1:4], digits=1) # arred com 1 d√≠gito
cos(sw$BMI[1:4]) # cosseno
sin(sw$BMI[1:4]) # seno
log(sw$BMI[1:4]) # logaritmo natural
log10(sw$BMI[1:4]) # logaritmo base 10
exp(sw$BMI[1:4]) # exponencial
```


### Jun√ß√£o de bases

- [Merging data (John Hopkins/Coursera)](https://www.coursera.org/learn/data-cleaning/lecture/pVV6K/merging-data)
- [Joining (Merging) Data (David E. Caughlin)](https://rforhr.com/join.html)

- Uma jun√ß√£o √© o processo de correspond√™ncia de casos (ou seja, linhas ou observa√ß√µes) entre dois bases de dados usando uma oou mais vari√°veis-chave:

<center><img src="../merge.webp"></center>

- Para isto, vamos usar a fun√ß√£o `merge()`:

```yaml
merge(x, y, by = intersect(names(x), names(y)),
      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,
      suffixes = c(".x",".y"), ...)

- x, y: data frames, or objects to be coerced to one.
- by, by.x, by.y: specifications of the columns used for merging.
- all: logical; all = L is shorthand for all.x = L and all.y = L, where L is either TRUE or FALSE.
- all.x: logical; if TRUE, then extra rows will be added to the output, one for each row in x that has no matching row in y. These rows will have NAs in those columns that are usually filled with values from y.
- all.y: logical; analogous to all.x.
- sort: logical. Should the result be sorted on the by columns?
- suffixes: a character vector of length 2 specifying the suffixes to be used for making unique the names of columns.
```

- Vamos criar duas bases de dados, sendo que existem indiv√≠duos presentes em uma base que n√£o est√° na outra:

```{r}
# Extraindo data frames menores de 'starwars' (original)
bd1 = starwars[1:6, c(1, 3, 11)]
bd1
bd2 = starwars[c(2, 4, 7:10), c(1:2, 6)]
bd2
```

- Note que h√° 12 personagens √∫nicos em ambas bases, mas apenas ‚ÄúC-3PO‚Äù e ‚ÄúDarth Vader‚Äù s√£o observa√ß√µes comuns.
- Para verificar as colunas com mesmos nomes em duas bases, podemos usar a fun√ß√£o `intersect()` em conjunto com a fun√ß√£o `names()` ou `colnames()`:
```{r}
intersect( names(bd1), names(bd2) )
```
- Caso n√£o especifiquemos nenhuma vari√°vel-chave, a fun√ß√£o `merge()` utiliza como vari√°vel-chave todas as colunas com nomes iguais.

##### Inner-join

<center><img src="../inner_join.png"></center>
```{r}
merge(bd1, bd2, all = FALSE)
```


##### Full-join

<center><img src="../full_join.png"></center>
```{r}
merge(bd1, bd2, all = TRUE)
```


##### Left-join

<center><img src="../left_join.png"></center>
```{r}
merge(bd1, bd2, all.x = TRUE)
```


##### Right-join

<center><img src="../right_join.png"></center>
```{r}
merge(bd1, bd2, all.y = TRUE)
```

</br>


## Pacote `dplyr`
- [Vignette - Introduction to _dplyr_](https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html)
- O pacote `dplyr` facilita a manipula√ß√£o dos dados por meio de fun√ß√µes simples e computacionalmente eficientes
- As fun√ß√µes pode, ser organizadas em tr√™s categorias:
    - Colunas:
        - `select()`: seleciona (ou retira) as colunas do data frame
        - `rename()`: muda os nomes das colunas
        - `mutate()`: cria ou muda os valores nas colunas
    - Linhas:
        - `filter()`: seleciona linhas de acordo com valores das colunas
        - `arrange()`: organiza a ordem das linhas
    - Grupo de linhas:
        - `summarise()`: colapsa um grupo em uma √∫nica linha
        - `group_by()`: agrupa base de dados a partir de uma vari√°vel categ√≥rica
- Nesta subse√ß√£o, continuaremos utilizando a base de dados de Star Wars (`starwars`), utilizada na subse√ß√£o anterior.
- Voc√™ ir√° notar que, ao usar essas fun√ß√µes, o data frame √© transformado em um _tibble_ que √© um formato mais eficiente para tratar dados tabulares, mas que funciona de forma igual a um data frame.

```{r}
sw = starwars # "limpando" sw com a base original
```


### Filtro via `filter()`
- Permite selecionar um subconjunto de linhas de um data frame
```yaml
filter(.data, ...)

- .data: A data frame, data frame extension (e.g. a tibble).
- ...	: Expressions that return a logical value, and are defined in terms of the variables in .data. If multiple expressions are included, they are combined with the & operator. Only rows for which all conditions evaluate to TRUE are kept.
```

```{r}
sw1 = filter(sw, species == "Human", height >= 100)
sw1 # j√° filtra os NA's
```



### Ordena√ß√£o via `arrange()`
- Reordena as linhas a partir de um conjunto de nomes de coluna
```yaml
arrange(.data, ..., .by_group = FALSE)

- .data: A data frame, data frame extension (e.g. a tibble).
- ... : Variables, or functions of variables. Use desc() to sort a variable in descending order.
```
- Se for inserido mais de um nome de vari√°vel, organiza de acordo com a 1¬™ vari√°vel e, em caso de ter linhas com o mesmo valor na 1¬™ vari√°vel, ordena estas linhas de mesmo valor de acordo com a 2¬™ vari√°vel
- Para usar a ordem decrescente, temos a fun√ß√£o `desc()`
```{r}
sw2 = arrange(sw1, height, desc(mass))
sw2
```



### Sele√ß√£o via `select()`
- Seleciona colunas que s√£o de interesse.
```yaml
select(.data, ...)

- ... : variables in a data frame
  - : for selecting a range of consecutive variables.
  - ! for taking the complement of a set of variables.
  - c() for combining selections.
```
- Coloca-se os nomes das colunas desejadas para selecion√°-las.
- Tamb√©m √© poss√≠vel selecionar um intervalo de vari√°veis usando `var1:var2`
- Caso queira tirar apenas algumas colunas, basta informar o nome delas precedidas pelo sinal de subtra√ß√£o (`-var`)
```{r}
sw3 = select(sw2, name:eye_color, sex:species)
sw3
```
- Note que o `select()` pode n√£o funcionar corretamente se o pacote `MASS` estiver ativo. Caso esteja, retire a sele√ß√£o do pacote `MASS` no quadrante inferior/direito em 'Packages' (ou digite `detach("package:MASS", unload = TRUE)`)
- Uma outra forma de fazer a sele√ß√£o de coluna √© combinando com `starts_with()` e `ends_with()`, que resulta na sele√ß√£o de colunas que se iniciam e terminam com um texto dado
```{r}
head( select(sw, ends_with("color")) ) # colunas que terminam com color
head( select(sw, starts_with("s")) ) # colunas que iniciam com a letra "s"
```



### Renomea√ß√£o via `rename()`
- Renomeia colunas usando `novo_nome = velho_nome`
```yaml
rename(.data, ...)

- .data: A data frame, data frame extension (e.g. a tibble).
- ...	: Use new_name = old_name to rename selected variables.
```

```{r}
sw4 = rename(sw3,
             haircolor = hair_color,
             skincolor = skin_color, 
             eyecolor = eye_color)
sw4
```



### Modifica√ß√£o via `mutate()`
- Modifica uma coluna se ela j√° existir
- Cria uma coluna se ela n√£o existir
```yaml
mutate(.data, ...)

- .data: A data frame, data frame extension (e.g. a tibble).
- ...	: Name-value pairs. The name gives the name of the column in the output.
 - A vector of length 1, which will be recycled to the correct length.
 - A vector the same length as the current group (or the whole data frame if ungrouped).
 - NULL, to remove the column.
```
```{r}
sw5 = mutate(sw4,
             height = height/100, # transf cm p/ metro
             BMI = mass / height^2,
             dummy = 1 # se n√£o for vetor, tudo fica igual
             )
sw5 = select(sw5, BMI, dummy, everything()) # reordena√ß√£o colunas
sw5
```



### Operador Pipe `%>%`
- Note que todas as fun√ß√µes do pacote `dyplr` anteriores t√™m como 1¬∫ argumento a base de dados (`.data`), e isto n√£o √© por acaso.
- O operador pipe `%>%` joga um data frame (escrito √† sua esquerda) no 1¬∫ argumento da fun√ß√£o seguinte (√† sua direita).
```{r}
filter(sw, species=="Droid") # sem operador pipe
sw %>% filter(species=="Droid") # com operador pipe
```
- Observe que, ao usar o operador pipe, o 1¬∫ argumento com a base de dados n√£o deve ser preenchida (j√° est√° sendo aplicada automaticamente via `%>%`).
- Note que, desde a subse√ß√£o com a fun√ß√£o `filter()` at√© `mutate()` fomos "acumulando" as altera√ß√µes em novos data frames, ou seja, o √∫ltimo data frame `starwars5` √© a base original `starwars` que foi alterada por `filter()`, `arrange()`, `select()`, `rename()` e `mutate()`.
```{r}
sw1 = filter(sw, species == "Human", height >= 100)
sw2 = arrange(sw1, height, desc(mass))
sw3 = select(sw2, name:eye_color, sex:species)
sw4 = rename(sw3,
             haircolor = hair_color,
             skincolor = skin_color, 
             eyecolor = eye_color)
sw5 = mutate(sw4,
             height = height/100,
             BMI = mass / height^2,
             dummy = 1
             )
sw5 = select(sw5, BMI, dummy, everything())
sw5
```
- Usando o operador pipe `%>%` v√°rias vezes, podemos ir pegando o output resultante da aplica√ß√£o de uma fun√ß√£o e jogar como input da fun√ß√£o seguinte. Reescreveremos o c√≥digo acima "em √∫nica linha" com `%>%`, chegando ao mesmo data frame de `starwars5`
```{r}
sw_pipe = sw %>% 
    filter(species == "Human", height >= 100) %>%
    arrange(height, desc(mass)) %>%
    select(name:eye_color, sex:species) %>%
    rename(haircolor = hair_color,
           skincolor = skin_color, 
           eyecolor = eye_color) %>%
    mutate(height = height/100,
           BMI = mass / height^2,
           dummy = 1
           ) %>%
    select(BMI, dummy, everything())
sw_pipe

all(sw_pipe == sw5, na.rm=TRUE) # verificando se todos elementos s√£o iguais
```



### Resumo via `summarise()`

- Podemos usar a fun√ß√£o `summarise()` para gerar alguma estat√≠stica acerca de uma ou mais vari√°veis:
```{r}
starwars %>% summarise(
    n_obs = n(),
    height_mean = mean(height, na.rm=TRUE),
    mass_mean = mean(mass, na.rm=TRUE)
    )
```
- No caso acima, gerou simplesmente o tamanho da amostra e as m√©dias de altura e de massa considerando a amostra inteira de `starwars` (o que n√£o foi muito √∫til).


#### Agrupamento via `group_by()`
- Diferente das outras fun√ß√µes do `dplyr` mostradas at√© agora, o output do `group_by` n√£o altera conte√∫do do data frame, apenas **transforma em uma base de dados agrupada** em categorias de uma dada vari√°vel
```{r}
grouped_sw = starwars %>% group_by(sex)
class(grouped_sw)

head(starwars)
head(grouped_sw) # agrupado por sexo
```
- O `group_by()` prepara o data frame para opera√ß√µes que consideram v√°rias linhas. Como exemplo, vamos criar uma coluna com a soma de `mass` de todas observa√ß√µes
```{r}
starwars %>%
    mutate(mass_mean = mean(mass, na.rm=TRUE)) %>% 
    select(mass_mean, sex, everything()) %>%
    head(10)
```
- Note que todos os valores de `mass_mean` s√£o iguais. Agora, agruparemos por `sex` antes de fazer a soma:
```{r}
starwars %>%
    group_by(sex) %>%
    mutate(mass_mean = mean(mass, na.rm=TRUE)) %>% 
    ungroup() %>% # Lembre-se sempre de desagrupar depois!
    select(mass_mean, sex, everything()) %>%
    head(10)
```
- Note que, agora, a coluna `mass_mean` tem valores diferentes de acordo com o sexo da observa√ß√£o.
- Isso √© √∫til em algumas aplica√ß√µes econ√¥micas em que consideramos vari√°veis a n√≠vel de grupo (e.g. domic√≠lio) a qual uma observa√ß√£o (e.g. morador) pertence.

> **Evite potenciais erros**: Sempre que usar `group_by()`, n√£o se esque√ßa de desagrupar o data frame via fun√ß√£o `ungroup()` ap√≥s realizar a opera√ß√µes desejadas.

#### Resumo por grupo via `group_by()` e `summarise()`
- A fun√ß√£o `summarise()` √© de fato √∫til quando combinada com a fun√ß√£o `group_by()`, pois conseguimos obter as estat√≠sticas de grupos:
```{r}
summary_sw = starwars %>% group_by(sex) %>%
    summarise(
        n_obs = n(),
        height_mean = mean(height, na.rm = TRUE),
        mass_mean = mean(mass, na.rm = TRUE)
    )
summary_sw
class(summary_sw) # ao usar summary, deixa de ser agrupada
```
- Note que, ao usar `summarise()`, o data frame resultante n√£o √© agrupado e, portanto, n√£o √© necess√°rio usar `ungroup()` neste caso.
- Tamb√©m √© poss√≠vel adicionar mais de uma vari√°vel para agrupar:
```{r}
starwars %>% group_by(sex, hair_color) %>%
    summarise(
        n_obs = n(),
        height_mean = mean(height, na.rm = TRUE),
        mass_mean = mean(mass, na.rm = TRUE)
    )
```
- Para agrupar vari√°veis **cont√≠nuas**, precisamos definir intervalos usando a fun√ß√£o `cut()`
```yaml
cut(x, ...)

x: a numeric vector which is to be converted to a factor by cutting.

breaks: either a numeric vector of two or more unique cut points or a single number (greater than or equal to 2) giving the number of intervals into which x is to be cut.
```
```{r}
# breaks com um integer = qtd desejada de grupos
starwars %>% group_by(cut(birth_year, breaks=5)) %>%
    summarise(
        n_obs = n(),
        height_mean = mean(height, na.rm = TRUE)
    )

# breaks com um vetor = quebras dos intervalos dos grupos
starwars %>% group_by(birth_year=cut(birth_year, 
                          breaks=c(0, 40, 90, 200, 900))) %>%
    summarise(
        n_obs = n(),
        height_mean = mean(height, na.rm = TRUE)
    )
```
- Note que inserimos `birth_year=cut(birth_year, ...)` para que o nome da coluna ficasse `birth_year`, caso contr√°rio a coluna ficaria com o nome `cut(birth_year, ...)`.




### Jun√ß√£o via _\*\_join()_
- Vimos anteriormente que, para agrupar bases de dados a partir de vari√°veis-chave, podemos usar a fun√ß√£o `merge()`.
- O pacote `dplyr` fornece uma fam√≠lia de fun√ß√µes _join_ que executam o mesmo comando que `merge()`, por√©m, ao inv√©s de alterar o valor de um argumento, voc√™ precisa escolher uma das fun√ß√µes _join_ que podem ser resumidas na seguinte figura:

<center><img src="../dplyr-data-join-functions.png"></center>

- Todas as fun√ß√µes possuem a mesma sintaxe:
    - `x`: base 1
    - `y`: base 2
    - `by`: vetor de vari√°veis-chave
    - `suffix`: vetor de 2 sufixos para incluir em colunas de mesmos nomes
- Como exemplo, usaremos subconjuntos da base de dados `starwars`:
```{r}
bd1 = starwars[1:6, c(1, 3, 11)]
bd1
bd2 = starwars[c(2, 4, 7:10), c(1:2, 6)]
bd2
```
- Note que h√° 12 personagens √∫nicos em ambas bases, mas apenas "C-3PO" e "Darth Vader" s√£o observa√ß√µes comuns.
- `inner_join()`: mant√©m apenas ID's presentes simultaneamente em ambas bases
```{r}
inner_join(bd1, bd2, by="name")
```

- `full_join()`: mant√©m todas ID's, mesmo que estejam em apenas em um das bases
```{r}
full_join(bd1, bd2, by="name")
```
- `left_join()`: mant√©m apenas ID's presentes na base 1 (informada como `x`)
```{r}
left_join(bd1, bd2, by="name")
```
- `right_join()`: mant√©m apenas ID's presentes na base 2 (informada como `y`)
```{r}
right_join(bd1, bd2, by="name")
```


</br>

{{< cta cta_text="üëâ Proceed to Data Visualization" cta_link="../sec4" >}}
