---
date: "2018-09-09T00:00:00Z"
# icon: book
# icon_pack: fas
linktitle: Manipulation
summary: It covers topics such as data manipulation, apply functions, etc. Also provides an introduction to the dplyr package and its functions for column manipulation (select, rename, mutate), row manipulation (filter, arrange), and grouping of rows (summarize). The page also includes examples of using these functions with the Star Wars dataset. Additionally, the page discusses the use of the pipe operator (%>%) and join functions for merging data frames.
title: Data Manipulation
weight: 3
output: md_document
type: book
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


</br>

## Resumindo dados

### Fun√ß√µes b√°sicas
- [Summarizing data (John Hopkins/Coursera)](https://www.coursera.org/learn/data-cleaning/lecture/e5qVi/summarizing-data)
- Para esta se√ß√£o, usaremos a base de dados `airquality`, j√° presente no R.
- Verificaremos o **dimens√µes** da base com `dim()` e visualizaremos as 6 **primeiras** e **√∫ltimas** linhas da base via `head()` e `tail()`, respectivamente.
```{r}
# data() # lista de base de dados presentes no R

dim(airquality) # Verificar tamanho da base (linhas x colunas)
head(airquality) # Visualizando as 6 primeiras linhas
tail(airquality) # Visualizando as 6 √∫ltimas linhas
```
- Usando `str()`, podemos visualizar a **estrutura** da base:
    - todas a vari√°veis (colunas),
    - a classe de cada uma delas e
    - algumas de suas observa√ß√µes.
```{r}
str(airquality)
```


- Para fazer um **resumo** de todas as vari√°veis da base, podemos usar a fun√ß√£o `summary()` que, para vari√°veis num√©ricas, calcula a m√©dia e os quartis, e mostra a quantidade de `NA`.
```{r}
summary(airquality)
```
- Tamb√©m podemos calcular os **quantis** via `quantile()`
```{r}
quantile(airquality$Ozone, probs=c(0, .25, .5 , .75, 1), na.rm=TRUE)
```

- Note que, para vari√°veis l√≥gicas, de texto ou categ√≥ricas (factor), aparecem a contagem de cada categoria/poss√≠vel valor:
```{r}
summary(CO2) # base de dados 'Carbon Dioxide Uptake in Grass Plants'
```
- Para vari√°veis de texto, pode ser interessante fazer uma **tabela com a contagem** de cada poss√≠vel categoria de uma vari√°vel. Isto √© poss√≠vel por meio da fun√ß√£o `table()` e aplicaremos `prop.table(table())` para visualizar em **percentuais**.
```{r}
table(CO2$Type) # contagem
prop.table(table(CO2$Type)) # percentual
```
- Tamb√©m podemos incluir mais uma vari√°vel em `table()` para visualizar a contagem considerando 2 vari√°veis:
```{r}
table(CO2$Type, CO2$Treatment)
```


### Fam√≠lia de fun√ß√µes _apply_
Veremos uma fam√≠lia de fun√ß√µes _apply_ que permitem executar comandos em loop de maneira compacta:
- `apply`: aplica uma fun√ß√£o sobre as margens (linha ou coluna) de uma matrix/array
- `lapply`: loop sobre uma lista e avalia uma fun√ß√£o em cada elemento
    - fun√ß√£o auxiliar `split` √© √∫til ao ser utilizada em conjunto da `lapply`
- `sapply`: mesmo que o `lapply`, mas simplifica o resultado



#### Fun√ß√£o `apply()`
- [Loop functions - apply (John Hopkins/Coursera)](https://www.coursera.org/learn/r-programming/lecture/IUUhK/loop-functions-apply)
- Usado para avaliar, por meio de uma fun√ß√£o, margens de um array
- Frequentemente √© utilizado para aplicar uma fun√ß√£o a linhas ou a colunas de uma matriz
- N√£o √© mais r√°pido do que escrever um loop, mas funciona em uma √∫nica linha
```yaml
apply(X, MARGIN, FUN, ...)

X: an array, including a matrix.MARGIN: a vector giving the subscripts which the function will be applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2) indicates rows and columns. Where X has named dimnames, it can be a character vector selecting dimension names.
FUN: the function to be applied: see ‚ÄòDetails‚Äô. In the case of functions like +, %*%, etc., the function name must be backquoted or quoted.
... : optional arguments to FUN.
```
```{r}
x = matrix(1:20, 5, 4)
x

apply(x, 1, mean) # m√©dias das linhas
apply(x, 2, mean) # m√©dias das colunas
```
- H√° fun√ß√µes pr√©-definidas que aplicam `apply` com soma e com m√©dia:
    - `rowSums = apply(x, 1, sum)`
    - `rowMeans = apply(x, 1, mean)`
    - `colSums = apply(x, 2, sum)`
    - `colMeans = apply(x, 2, mean)`
- Podemos, por exemplo, tamb√©m calcular os quantis de uma matriz usando a fun√ß√£o `quantile()`
```{r}
x = matrix(1:50, 10, 5) # matriz 20x10 - 200 n√∫meros ~ N(0, 1)
x


apply(x, 2, quantile) # obtendo os quantis de cada coluna
```
- Com tamb√©m podemos verificar quais s√£o os valores √∫nicos de cada vari√°vel em um data frame combinando `apply()` e `unique()`
```{r}
apply(mtcars, 2, unique)
``` 


- Podemos verificar o **n√∫mero de NA's** em cada coluna usando `apply()` com `sum` (ou tamb√©m `colSums()`) na base de dados com `is.na()` (transforma a base de dados em TRUE/FALSE se for ou n√£o `NA`)
```{r}
head( is.na(airquality) ) # 6 primeiras linhas aplicando is.na()
apply(is.na(airquality), 2, sum) # somando cada coluna de TRUE/FALSE
```


#### Fun√ß√£o `lapply()`
- [Loop functions - lapply (John Hopkins/Coursera)](https://www.coursera.org/learn/r-programming/lecture/t5iuo/loop-functions-lapply)
- `lapply` usa tr√™s argumentos: uma **lista**, o nome de uma fun√ß√£o e outros argumentos (incluindo os da fun√ß√£o inserida)
```yaml
lapply(X, FUN, ...)

X: a vector (atomic or list) or an expression object. Other objects (including classed objects) will be coerced by base::as.list.
FUN: the function to be applied to each element of X: see ‚ÄòDetails‚Äô. In the case of functions like +, %*%, the function name must be backquoted or quoted.
... : optional arguments to FUN.
```
```{r}
# Criando uma lista com vetor de dimens√µes distintas
x = list(a=1:5, b=rnorm(10), c=c(1, 4, 65, 6))
x

lapply(x, mean) # retorna m√©dias de cada vetor dentro da lista
lapply(x, summary) # retorna 6 estat√≠sticas de cada vetor dentro da lista

class(lapply(x, mean)) # classe do objeto retornado pelo lapply
```


#### Fun√ß√£o `sapply()`
Similar ao `lapply`, mas `sapply` tenta simplificar o output:

- Se o resultado for uma lista em que todo elemento tem comprimento 1 (tem apenas um elemento tamb√©m), retorna um vetor
```{r}
sapply(x, mean) # retorna um vetor
```
- Se o resultado for uma lista em que cada elemento tem mesmo comprimento, retorna uma matriz
```{r}
sapply(x, summary) # retorna uma matriz
```



</br>

## Manipulando dados

> ‚ÄúBetween 30% to 80% of the data analysis task is spent on cleaning and understanding the data.‚Äù (Dasu \& Johnson, 2003)

### Extra√ß√£o de subconjuntos
- [Subsetting and sorting (John Hopkins/Coursera)](https://www.coursera.org/learn/data-cleaning/lecture/aqd2Y/subsetting-and-sorting)
- Como exemplo, criaremos um _data frame_ com tr√™s vari√°veis, em que, para misturar a ordem dos n√∫meros, usaremos a fun√ß√£o `sample()` num vetor de n√∫meros e tamb√©m incluiremos alguns valores ausentes `NA`.
```{r}
x = data.frame(var1=sample(1:5), var2=sample(6:10), var3=sample(11:15))
x

x$var2[c(1, 3)] = NA
x
```
- Lembre-se que, para extrair um subconjunto de um data frame, usamos as chaves `[]` indicando vetores de linhas e de colunas (ou tamb√©m os nomes das colunas).
```{r}
x[, 1] # Todas linhas e 1¬™ coluna
x[, "var1"] # Todas linhas e 1¬™ coluna (usando seu nome)
x[1:2, "var2"] # Linhas 1 e 2, e 2¬™ coluna (usando seu nome)
```
- Note que, podemos usar express√µes l√≥gicas (vetor com `TRUE` e `FALSE`) para extrair uma parte do data frame. Por exemplo, queremos obter apenas as observa√ß√µes em que a vari√°vel 1 seja menor ou igual a 3 **E** (`&`) que a vari√°vel 3 seja estritamente maior do que 11:
```{r}
x$var1 <= 3 & x$var3 > 11

# Extraindo as linhas de x
x[x$var1 <= 3 & x$var3 > 11, ]
```
- Poder√≠amos tamb√©m obter apenas as observa√ß√µes em que a vari√°vel 1 seja menor ou igual a 3 **OU** (`|`) que a vari√°vel 3 seja estritamente maior do que 11:
```{r}
x[x$var1 <= 3 | x$var3 > 11, ]
```
- Tamb√©m podemos verificar se determinados valores est√£o contidos em um vetor espec√≠fico (equivale `==` com mais de um valor)
```{r}
x$var1 %in% c(1, 5) # obs em que var1 √© igual a 1 ou 5
x[x$var1 %in% c(1, 5), ]
```

- Note que, ao escrevermos uma express√£o l√≥gica para um vetor que cont√©m valores ausentes, gerar√° um vetor com `TRUE`, `FALSE` e `NA`
```{r}
x$var2 > 8
x[x$var2 > 8, ]
```
- Para contornar este problema, podemos usar a fun√ß√£o `which()` que, ao inv√©s de gerar um vetor de `TRUE`/`FALSE`, retorna um vetor com as posi√ß√µes dos elementos que tornam a express√£o l√≥gica verdadeira
```{r}
which(x$var2 > 8)
x[which(x$var2 > 8), ]
```
- Outra forma de contornar os valores ausentes √© incluir a condi√ß√£o 
de n√£o incluir valores ausentes `!is.na()`:
```{r}
x$var2 > 8 & !is.na(x$var2)
x[x$var2 > 8 & !is.na(x$var2), ]
```


### Ordena√ß√£o
- Podemos usar a fun√ß√£o `sort()` para ordenar um vetor de maneira crescente (padr√£o) ou decrescente:
```{r}
sort(x$var1) # ordenando de maneira crescente
sort(x$var1, decreasing=TRUE) # ordenando de maneira decrescente
```
- Por padr√£o, o `sort()` retira os valores ausentes. Para mant√™-los e deix√°-los no final, precisamos usar o argumento `na.last=TRUE`
```{r}
sort(x$var2) # ordenando e retirando NA
sort(x$var2, na.last=TRUE) # ordenando e mantendo NA no final
```
- Note que n√£o podemos usar a fun√ß√£o `sort()` para ordenar um data frame, pois a fun√ß√£o retorna valores e, portanto, n√£o retorna suas posi√ß√µes.
```{r}
sort(x$var3)
x[sort(x$var3), ] # Retorna erro, pois n√£o h√° n¬∫ de linhas > 5
```
- Para ordenar data frames, precisamos utilizar a fun√ß√£o `order()` que, ao inv√©s de retorar os valores em algum ordem, retorna as suas posi√ß√µes
```{r}
order(x$var3)
x[order(x$var3), ] # Retorna erro, pois n√£o h√° n¬∫ de linhas > 5
```

### Inclus√£o de novas colunas/vari√°veis
- Para incluir novas vari√°veis, podemos usar `$<novo_nome_var>` e atribuir um vetor de mesmo tamanho (mesma quantidade de linhas):
```{r}
x$var4 = 5:1
x
```

- [Algumas transforma√ß√µes comuns de vari√°veis (John Hopkins/Coursera)](https://www.coursera.org/learn/data-cleaning/lecture/r6VHJ/creating-new-variables)
```{r}
abs(x$var4) # valor absoluto
sqrt(x$var4) # raiz quadrada
ceiling(x$var4) # valor inteiro acima
floor(x$var4) # valor inteiro abaixo
round(x$var4, digits=1) # arredondamento com 1 d√≠gito
cos(x$var4) # cosseno
sin(x$var4) # seno
log(x$var4) # logaritmo natural
log10(x$var4) # logaritmo base 10
exp(x$var4) # exponencial
```



### Juntando bases de dados

#### Acrescentando colunas e linhas via `cbind()` e `rbind()`

- Uma maneira de juntar o data frame com um vetor de mesmo tamanho √© usando `cbind()`
```{r}
y = rnorm(5)
x = cbind(x, y)
x
```
- Tamb√©m podemos acrescentar linhas usando `rbind()`, desde que o vetor tenha a quantidade de elementos igual ao n√∫mero de colunas (ou data frame a ser inclu√≠do tenha o mesmo n√∫mero de colunas)
```{r}
z = rnorm(5)
x = rbind(x, z)
x
```


#### Mesclando base de dados com `merge()`
- [Merging data (John Hopkins/Coursera)](https://www.coursera.org/learn/data-cleaning/lecture/pVV6K/merging-data)
- Podemos juntar base de dados a partir de uma vari√°vel-chave que aparece em ambas bases.
- Como exemplo, utilizaremos duas bases de dados de respostas a perguntas ([`solutions.csv`](https://fhnishida-rec5004.netlify.app/docs/solutions.csv)) e de corre√ß√µes feitas por seus pares ([`reviews.csv`](https://fhnishida-rec5004.netlify.app/docs/reviews.csv)).
```{r}
solutions = read.csv("https://fhnishida.netlify.app/project/rec5004/solutions.csv")
head(solutions)

reviews = read.csv("https://fhnishida.netlify.app/project/rec5004/reviews.csv")
head(reviews)
```
- Note que:
    - as primeiras colunas das bases `solutions` e `reviews`` s√£o os identificadores √∫nicos das solu√ß√µes e dos reviews, respectivamente.
    - na base `reviews` h√° a coluna _problem_id_ que faz a liga√ß√£o entre esta base com a coluna _id_ da base `solutions`.
- Usaremos a fun√ß√£o `merge()` para juntar ambas bases em uma s√≥, a partir do id da solu√ß√£o.

```yaml
merge(x, y, by = intersect(names(x), names(y)),
      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,
      sort = TRUE, suffixes = c(".x",".y"), ...)

x, y: data frames, or objects to be coerced to one.
by, by.x, by.y: specifications of the columns used for merging. See ‚ÄòDetails‚Äô.
all: logical; all = L is shorthand for all.x = L and all.y = L, where L is either TRUE or FALSE.
all.x: logical; if TRUE, then extra rows will be added to the output, one for each row in x that has no matching row in y. These rows will have NAs in those columns that are usually filled with values from y. The default is FALSE, so that only rows with data from both x and y are included in the output.
all.y: logical; analogous to all.x.
sort: logical. Should the result be sorted on the by columns?
suffixes: a character vector of length 2 specifying the suffixes to be used for making unique the names of columns in the result which are not used for merging (appearing in by etc).
```

<center><img src="../merge.webp"></center>

```{r}
mergedData = merge(reviews, solutions,
                   by.x="solution_id",
                   by.y="id",
                   all=TRUE)
head(mergedData)
```

- Note que, como h√° colunas de mesmos nomes, e especificamos que a vari√°vel chave era somente o id de solu√ß√£o, ent√£o as colunas de nomes iguais foram renomeadas com sufixos `.x` e `.y`, correspondendo √†s 1¬™ e 2¬™ bases inseridas na fun√ß√£o `merge()`
- Para verificar as colunas com mesmos nomes em duas bases, podemos usar a fun√ß√£o `intersect()` em conjunto com a fun√ß√£o `names()`:
```{r}
intersect( names(solutions), names(reviews) )
```
- Se n√£o especific√°ssemos nenhuma vari√°vel-chave, a fun√ß√£o `merge()` utilizaria como vari√°vel-chave todas as colunas com nomes iguais em ambas bases de dados 
```{r}
wrong = merge(reviews, solutions,
                   all=TRUE)
head(wrong)
```



</br>

## Pacote `dplyr`
- [Vignette - Introduction to _dplyr_](https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html)
- O pacote `dplyr` facilita a manipula√ß√£o dos dados por meio de fun√ß√µes simples e computacionalmente eficientes
- As fun√ß√µes pode, ser organizadas em tr√™s categorias:
    - Colunas:
        - `select()`: seleciona (ou retira) as colunas do data frame
        - `rename()`: muda os nomes das colunas
        - `mutate()`: cria ou muda os valores nas colunas
    - Linhas:
        - `filter()`: seleciona linhas de acordo com valores das colunas
        - `arrange()`: organiza a ordem das linhas
    - Grupo de linhas:
        - `summarise()`: colapsa um grupo em uma √∫nica linha
- Nesta subse√ß√£o, continuaremos utilizando a base de dados de Star Wars (`starwars`), utilizada na subse√ß√£o anterior.
- Voc√™ ir√° notar que, ao usar essas fun√ß√µes, o data frame √© transformado em um _tibble_ que √© um formato mais eficiente para tratar dados tabulares, mas que funciona de forma igual a um data frame.

```{r}
library("dplyr") # Carregando pacote
head(starwars) # olhando primeiras linhas da base contida no pacote
```



### Filtre linhas com `filter()`
- Permite selecionar um subconjunto de linhas de um data frame
```yaml
filter(.data, ...)

.data: A data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).
...	: <data-masking> Expressions that return a logical value, and are defined in terms of the variables in .data. If multiple expressions are included, they are combined with the & operator. Only rows for which all conditions evaluate to TRUE are kept.
```
- 
```{r}
starwars1 = filter(starwars, species == "Human", height >= 100)
starwars1

# Equivalente a:
starwars[starwars$species == "Human" & starwars$height >= 100, ]
```



### Organize linhas com `arrange()`
- Reordena as linhas a partir de um conjunto de nomes de coluna
```yaml
arrange(.data, ..., .by_group = FALSE)

.data: A data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).
... : <data-masking> Variables, or functions of variables. Use desc() to sort a variable in descending order.
```
- Se for inserido mais de um nome de vari√°vel, organiza de acordo com a 1¬™ vari√°vel e, em caso de ter linhas com o mesmo valor na 1¬™ vari√°vel, ordena estas linhas de mesmo valor de acordo com a 2¬™ vari√°vel
- Para usar a ordem decrescente, temos a fun√ß√£o `desc()`
```{r}
starwars2 = arrange(starwars1, height, desc(mass))
starwars2
```



### Selecione colunas com `select()`
- Seleciona colunas que s√£o de interesse.
```yaml
select(.data, ...)

... : variables in a data frame
: for selecting a range of consecutive variables.
! for taking the complement of a set of variables.
c() for combining selections.
```
- Coloca-se os nomes das colunas desejadas para selecion√°-las.
- Tamb√©m √© poss√≠vel selecionar um intervalo de vari√°veis usando `var1:var2`
- Caso queira tirar apenas algumas colunas, basta informar o nome delas precedidas pelo sinal de subtra√ß√£o (`-var`)
```{r}
starwars3 = select(starwars2, name:eye_color, sex:species)
# equivalente: select(starwars2, -birth_year, -c(films:starships))
starwars3
```
- Note que o `select()` pode n√£o funcionar corretamente se o pacote `MASS` estiver ativo. Caso esteja, retire a sele√ß√£o do pacote `MASS` no quadrante inferior/direito em 'Packages' (ou digite `detach("package:MASS", unload = TRUE)`)
- Uma outra forma de fazer a sele√ß√£o de coluna √© combinando com `starts_with()` e `ends_with()`, que resulta na sele√ß√£o de colunas que se iniciam e terminam com um texto dado
```{r}
head( select(starwars, ends_with("color")) ) # colunas que terminam com color
head( select(starwars, starts_with("s")) ) # colunas que iniciam com a letra "s"
```



### Renomeie colunas com `rename()`
- Renomeia colunas usando `novo_nome = velho_nome`
```yaml
rename(.data, ...)

.data: A data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).
...	: For rename(): <tidy-select> Use new_name = old_name to rename selected variables.
```

```{r}
starwars4 = rename(starwars3,
                haircolor = hair_color,
                skincolor = skin_color, 
                eyecolor = eye_color)
starwars4
```



### Modifique/Adicione colunas com `mutate()`
- Modifica uma coluna se ela j√° existir
- Cria uma coluna se ela n√£o existir
```yaml
mutate(.data, ...)

.data: A data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).
...	: <data-masking> Name-value pairs. The name gives the name of the column in the output. The value can be:
 - A vector of length 1, which will be recycled to the correct length.
 - A vector the same length as the current group (or the whole data frame if ungrouped).
 - NULL, to remove the column.
```
```{r}
starwars5 = mutate(starwars4,
                height = height/100, # transf cm p/ metro
                BMI = mass / height^2,
                dummy = 1 # se n√£o for vetor, tudo fica igual
                )
starwars5 = select(starwars5, BMI, dummy, everything()) # facilitar
starwars5
```



### Operador Pipe `%>%`
- Note que todas as fun√ß√µes do pacote `dyplr` anteriores t√™m como 1¬∫ argumento a base de dados (`.data`), e isto n√£o √© por acaso.
- O operador pipe `%>%` joga um data frame (escrito √† sua esquerda) no 1¬∫ argumento da fun√ß√£o seguinte (√† sua direita).
```{r}
filter(starwars, species=="Droid") # sem operador pipe
starwars %>% filter(species=="Droid") # com operador pipe
```
- Observe que, ao usar o operador pipe, o 1¬∫ argumento com a base de dados n√£o deve ser preenchida (j√° est√° sendo aplicada automaticamente via `%>%`).
- Note que, desde a subse√ß√£o com a fun√ß√£o `filter()` at√© `mutate()` fomos "acumulando" as altera√ß√µes em novos data frames, ou seja, o √∫ltimo data frame `starwars5` √© a base original `starwars` que foi alterada por `filter()`, `arrange()`, `select()`, `rename()` e `mutate()`.
```{r}
starwars1 = filter(starwars, species == "Human", height >= 100)
starwars2 = arrange(starwars1, height, desc(mass))
starwars3 = select(starwars2, name:eye_color, sex:species)
starwars4 = rename(starwars3,
                haircolor = hair_color,
                skincolor = skin_color, 
                eyecolor = eye_color)
starwars5 = mutate(starwars4,
                height = height/100,
                BMI = mass / height^2,
                dummy = 1
                )
starwars5 = select(starwars5, BMI, dummy, everything())
starwars5
```
- Usando o operador pipe `%>%` v√°rias vezes, podemos ir pegando o output resultante da aplica√ß√£o de uma fun√ß√£o e jogar como input da fun√ß√£o seguinte. Reescreveremos o c√≥digo acima "em √∫nica linha" com `%>%`, chegando ao mesmo data frame de `starwars5`
```{r}
starwars_pipe = starwars %>% 
    filter(species == "Human", height >= 100) %>%
    arrange(height, desc(mass)) %>%
    select(name:eye_color, sex:species) %>%
    rename(haircolor = hair_color,
           skincolor = skin_color, 
           eyecolor = eye_color) %>%
    mutate(height = height/100,
           BMI = mass / height^2,
           dummy = 1
           ) %>%
    select(BMI, dummy, everything())
starwars_pipe

all(starwars_pipe == starwars5, na.rm=TRUE) # verificando se todos elementos s√£o iguais
```



### Resuma com `summarise()`

- Podemos usar a fun√ß√£o `summarise()` para gerar alguma estat√≠stica acerca de uma ou mais vari√°veis:
```{r}
starwars %>% summarise(
    n_obs = n(),
    mean_height = mean(height, na.rm=TRUE),
    mean_mass = mean(mass, na.rm=TRUE)
    )
```
- No caso acima, gerou simplesmente o tamanho da amostra e as m√©dias de altura e de massa considerando a amostra inteira de `starwars` (o que n√£o foi muito √∫til).



### Agrupe com `group_by()`
- Diferente das outras fun√ß√µes do `dplyr` mostradas at√© agora, o output do `group_by` n√£o altera conte√∫do do data frame, apenas **transforma em uma base de dados agrupada** em categorias de uma dada vari√°vel
```{r}
grouped_sw = starwars %>% group_by(sex)
class(grouped_sw)

head(starwars)
head(grouped_sw) # agrupado por sexo
```
- O `group_by()` prepara o data frame para opera√ß√µes que consideram v√°rias linhas. Como exemplo, vamos criar uma coluna com a soma de `mass` de todas observa√ß√µes
```{r}
starwars %>%
    mutate(mean_mass = mean(mass, na.rm=TRUE)) %>% 
    select(mean_mass, sex, everything()) %>%
    head(10)
```
- Note que todos os valores de `mean_mass` s√£o iguais. Agora, agruparemos por `sex` antes de fazer a soma:
```{r}
starwars %>%
    group_by(sex) %>%
    mutate(mean_mass = mean(mass, na.rm=TRUE)) %>% 
    ungroup() %>% # Lembre-se sempre de desagrupar depois!
    select(mean_mass, sex, everything()) %>%
    head(10)
```
- Note que, agora, a coluna `mean_mass` tem valores diferentes de acordo com o sexo da observa√ß√£o.
- Isso √© √∫til em algumas aplica√ß√µes econ√¥micas em que consideramos vari√°veis a n√≠vel de grupo (e.g. domic√≠lio) a qual uma observa√ß√£o (e.g. morador) pertence.

> **Evite potenciais erros**: Sempre que usar `group_by()`, n√£o se esque√ßa de desagrupar o data frame via fun√ß√£o `ungroup()` ap√≥s realizar a opera√ß√µes desejadas.


### Resuma em grupos com `group_by()` e `summarise()`
- A fun√ß√£o `summarise()` √© de fato √∫til quando combinada com a fun√ß√£o `group_by()`, pois conseguimos obter as estat√≠sticas de grupos:
```{r}
summary_sw = starwars %>% group_by(sex) %>%
    summarise(
        n_obs = n(),
        mean_height = mean(height, na.rm = TRUE),
        mean_mass = mean(mass, na.rm = TRUE)
    )
summary_sw
class(summary_sw) # ao usar summary, deixa de ser agrupada
```
- Note que, ao usar `summarise()`, o data frame resultante n√£o √© agrupado e, portanto, n√£o √© necess√°rio usar `ungroup()` neste caso.
- Tamb√©m √© poss√≠vel adicionar mais de uma vari√°vel para agrupar:
```{r}
starwars %>% group_by(sex, hair_color) %>%
    summarise(
        n_obs = n(),
        mean_height = mean(height, na.rm = TRUE),
        mean_mass = mean(mass, na.rm = TRUE)
    )
```
- Para agrupar vari√°veis **cont√≠nuas**, precisamos definir intervalos usando a fun√ß√£o `cut()`
```yaml
cut(x, ...)

x: a numeric vector which is to be converted to a factor by cutting.

breaks: either a numeric vector of two or more unique cut points or a single number (greater than or equal to 2) giving the number of intervals into which x is to be cut.
```
```{r}
# breaks com um integer = qtd desejada de grupos
starwars %>% group_by(cut(birth_year, breaks=5)) %>%
    summarise(
        n_obs = n(),
        mean_height = mean(height, na.rm = TRUE)
    )

# breaks com um vetor = quebras dos intervalos dos grupos
starwars %>% group_by(birth_year=cut(birth_year, 
                          breaks=c(0, 40, 90, 200, 900))) %>%
    summarise(
        n_obs = n(),
        mean_height = mean(height, na.rm = TRUE)
    )
```
- Note que inserimos `birth_year=cut(birth_year, ...)` para que o nome da coluna ficasse `birth_year`, caso contr√°rio a coluna ficaria com o nome `cut(birth_year, ...)`.



### Junte bases com fun√ß√µes _join_
- Vimos anteriormente que podemos usar o `cbind()` juntar um data frame com outro data frame (ou vetor), caso tenham o mesmo n√∫mero de linhas
- Para juntar linhas (considerando que as colunas possuem as mesmas classes de vari√°veis), podemos usar o `rbind`
- Para agrupar bases de dados a partir de vari√°veis-chave, usamos a fun√ß√£o `merge()`.
- O pacote `dplyr` fornece uma fam√≠lia de fun√ß√µes _join_ que executam o mesmo comando que `merge()`, por√©m, ao inv√©s de alterar o valor de um argumento, voc√™ precisa escolher uma das fun√ß√µes _join_ que podem ser resumidas na seguinte figura:

<center><img src="../dplyr-data-join-functions.png"></center>

- Todas as fun√ß√µes possuem a mesma sintaxe:
    - `x`: base 1
    - `y`: base 2
    - `by`: vetor de vari√°veis-chave
    - `suffix`: vetor de 2 sufixos para incluir em colunas de mesmos nomes
- Como exemplo, usaremos subconjuntos da base de dados `starwars`:
```{r}
bd1 = starwars[1:6, c(1, 3, 11)]
bd2 = starwars[c(2, 4, 7:10), c(1:2, 6)]
bd1
bd2
```
- Note que h√° 12 personagens √∫nicos em ambas bases, mas apenas "C-3PO" e "Darth Vader" s√£o observa√ß√µes comuns.
- `inner_join()`: mant√©m apenas ID's presentes simultaneamente em ambas bases
```{r}
inner_join(bd1, bd2, by="name")
```

- `full_join()`: mant√©m todas ID's, mesmo que estejam em apenas em um das bases
```{r}
full_join(bd1, bd2, by="name")
```
- `left_join()`: mant√©m apenas ID's presentes na base 1 (informada como `x`)
```{r}
left_join(bd1, bd2, by="name")
```
- `right_join()`: mant√©m apenas ID's presentes na base 2 (informada como `y`)
```{r}
right_join(bd1, bd2, by="name")
```

- Note que podemos incluir mais de uma vari√°vel-chave para correspond√™ncia entre ID's de ambas bases. Primeiro, vamos construir as bases como paineis
```{r}
bd1 = starwars[1:5, c(1, 3)]
bd1 = rbind(bd1, bd1) %>%
    mutate(year = c(rep(2021, 5), rep(2022, 5)),
           # Se n√£o for ano 2021, multiplica por um n√∫mero aleat√≥rio ~ N(1, 0.025)
           mass = ifelse(year == 2021, mass, mass*rnorm(10, 1, 0.025))) %>%
    select(name, year, mass) %>%
    arrange(name, year)
bd1

bd2 = starwars[c(2, 4, 7:9), 1:2]
bd2 = rbind(bd2, bd2) %>%
    mutate(year = c(rep(2021, 5), rep(2022, 5)),
           # Se n√£o for ano 2021, altura cresce 2%
           height = ifelse(year == 2021, height, height*1.02)) %>%
    select(name, year, height) %>%
    arrange(name, year)
bd2
```
- Note agora que, para cada personagem, temos 2 linhas que correspondem aos dois anos (2021 e 2022). Faremos um `full_join()` considerando como vari√°veis-chave ambos `name` e `year`.
```{r}
# Juntando as bases
full_join(bd1, bd2, by=c("name", "year"))
```
- Atente-se tamb√©m aos nomes das vari√°veis, pois ao juntar bases com vari√°veis de mesmos nomes (que n√£o s√£o usadas como chave), a fun√ß√£o acaba incluindo ambas vari√°veis renomeadas, por padr√£o, com sufixos `.x` e `.y` (sufixos podem ser alterados pelo argumento `suffix`)
```{r}
bd2 = bd2 %>% mutate(mass = rnorm(10)) # Criando uma vari√°vel mass

full_join(bd1, bd2, by=c("name", "year"))
```


</br>

{{< cta cta_text="üëâ Proceed to Data Visualization" cta_link="../sec4" >}}
